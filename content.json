{"pages":[],"posts":[{"title":"别只将Codable用来解Json,-玩转你的模型吧---","text":"别只将Codable用来解Json,-玩转你的模型吧 本文代码使用Swift 4 代码:https://github.com/jamesdouble/JDSwiftHeatMap 前言自从 Swift 4 出来之后（现已4.1），相信不少读者已经看过无数国内外篇的文章在介绍 Swift 4 当中的一个新功能 Codable，之所以会火，不外乎就是为一个目前普遍业务上对伺服器回调Json -&gt; 自定义模型这个流程开了一条捷径，也附加了不少弹性。本篇文章不是着重于Codable的协议或是转换，而是Codable能帮助我解决以下的问题，所以其他就不赘述了。 Custom Encoding and Decoding 只关心Codable可跳到用Codable随机自定义模型 Problem最近在工作上做了几个类似单元开发的测试，需要大量的测试面对各型各样的数据UI能否正常展示，需要一个能将自己模型数据随机化的一个框架。 第一时间当然是找找有没有符合的框架能用😅😅，各种关键字组合搜索后，还是没看到能达成这块需求的（可能是我没搜索到，在这也求介绍）， 最后还是决定自己来写一个阳春版的模型随机框架。 目的12345678910struct MyStruct { var opt: Int var opt2: Int}foo = 某function(MyStruct)foo.opt // 4242foo.opt2 // 1234 初步Approach要能做到把自己自定义的模型交给程序去随机，就一定得从动态调用起手，否则框架就无法得知你自定义的模型 变量名，变量的型别…等，进而无法针对你的变量打乱。 以下我就尝试了几个常用的动态调用，比较他们各自的优缺： 单纯使用 Mirror + Protocol 缺少诸多已知要素 在静态调用环境下的Swift, Mirror算是比较特殊了，虽然没有Runtime牛（Apple管它叫做反射），但也是个很好用的框架。 优点： 可兼容任何自定义的Struct, Class，且是纯Swift。 缺点： 因为不去限制特定的已知类型，故只能识别它的变量类型跟读取变量数值，并没有附带反过来赋值的通道。 性能较差。 没有办法做树状处理。 使用Protocol手动赋值 需要手动去判断每个回传回来的key再自行去赋值，完全是不可行的方法。 同上缺点，使用Mirror一定得放尽一个实例，不能只传Type，全写出来其实也不单纯了。 1234567891011121314151617181920212223242526272829303132333435363738protocol RandProtocol { mutating func randResult(key: String, value: Any) static func initRand() -&gt; RandProtocol}struct JamesStruct: RandProtocol { var opt: Int = 0 mutating func randResult(key: String, value: Any) { if key == &quot;opt&quot; { if let intvalue = value as? Int { self.opt = intvalue } } } static func initRand() -&gt; RandProtocol { return JamesStruct() }}class RandMyMod&lt;T: RandProtocol&gt; { func randByMirror() -&gt; T { guard var newObject: T = T.initRand() as? T else { fatalError() } let mirror = Mirror(reflecting: newObject) for child in mirror.children { if child.value is Int { newObject.randResult(key: child.label!, value: (Int(arc4random_uniform(100) + 1))) } else if child.value is Float { /// } } return newObject }}let james = RandMyMod&lt;JamesStruct&gt;().randByMirror()james.opt 最方便但限制多 NSObject 优点： 继承的Class可以共用NSObject的init()方法，这样就不需要在使用时要传进一个实例，能直接从Type T 初始化一个实例 T()，即可对他进行赋值。 拥有方法.value(forKey:)，只要能取得变量名称就能取得变量数值，进而用此数值判断之后要set的Value是什么样的类型，当然在NSObject里要取得变量名称也不难。 缺点： 必须要继承 NSObject，但个人偏好使用 struct 来实作大部分的Data模型，也代表没办法使用任何继承。 在此Class下的任何自定义模型的变量也必须要是NSObject，才能做树状的随机，否则将停止。 1234567class A: NSObject { var foo: B //此变量无法被识别, 也无法被更改}class B { var num: Int} 搭配Runtime 12345678910111213141516171819202122class James: NSObject { @objc var opt: Int = 0 @objc var opt2: Int = 0}class RandMyMod&lt;T: NSObject&gt; { func rand() -&gt; T { var count: UInt32 = 0 var newObject: T = T() guard let properties = class_copyPropertyList(T.self, &amp;count) else { fatalError() } for i in 0..&lt;count { let pro = properties[Int(i)] let name = property_getName(pro) let str = String(cString: name) newObject.setValue(Int(arc4random_uniform(100) + 1), forKey: str) } return newObject }}let james = RandMyMod&lt;James&gt;().rand()james.opt // == 20james.opt2 // == 45 说到最完善最op的动态调用，肯定是Objective-C向的Runtime了，设置最少也最直观，我之所以最后不采用的原因： 目前框架整体方向还是希望能以纯Swift为主，不想使用类OC方法。 有使用RunTime的框架对于主程序的侵入性还是较大的，希望此框架是以辅助性的工具类为主。 搭配Mirror 12345678910111213141516171819class RandMyMod&lt;T: NSObject&gt; { func randByMirror() -&gt; T { var newObject: T = T() let mirror = Mirror(reflecting: T()) for child in mirror.children { if child.value is Int { newObject.setValue(Int(arc4random_uniform(100) + 1), forKey: child.label!) } else if child.value is Float { /// } } return newObject }}let james2 = RandMyMod&lt;James&gt;().randByMirror()james2.opt // == 55james2.opt2 // == 74 Mirror 在取得变量名称与变量类型的判断上明显比看起来简易许多，但他的局限性其实跟Runtime差不多，效能甚至比Runtime跟差，若是变量数量较多会导致影响到线程的运行。 平均需求 Codable先说Codable跟动态调用其实一点毛关系也没有，第一时间也是没想到的，但平均了以上两个的优缺，我却发现Codable能涵盖几个问题的优化： Struct, Class 都能使用，因为Codable是协议 赋值问题，说是json自动生成模型实例，那理解成用json自动赋值给一个模型，没啥毛病 没有使用Mirror 或是 Runtime 效能消耗很低，几乎是单纯的改值而已 唯一比较没法在更优化(或是我没想到)的两点： 无法单纯使用 Codable type 去初始化一个实例 若要做树状的随机，变量也得是Codable。 12345678910111213class Man: Codable { var name: String = &quot;&quot; var address: String = &quot;&quot; var website: [String] = []} let man = Man()RandMyMod&lt;Man&gt;().randMe(baseOn: man) { (newMan) in guard let new = newMan else { return } print(new.address) //mnxvpkalug print(new.name) //iivjohpggb print(new.website) //[&quot;pbmsualvei&quot;, &quot;vlqhlwpajf&quot;, &quot;npgtxdmfyt&quot;]} Implement整个流程很单纯就是： 实例 encode 成 Data 12func randMe(baseOn instance: T, completion: (T?)-&gt; ()) { let jsonData = try JSONEncoder().encode(instance) Data 转成 Dictionary 1let jsonDic = try JSONSerialization.jsonObject(with: jsonData, options: .mutableContainers) 随机Dictionary的元素 基本上原本最复杂的取值赋值问题，Codable都已经大家常用的标准方法了，所以本框架就只需要在这一步，处理树状的递回随机，并着墨一些附加功能。 树状的递回随机 主要处理只在这个类RandFactory： 它的init（注入一个 Value: Any, key变量名: String)，外部调他的function - randData() 即可获得跟注入同类型的，且已随机的值。 可注入的类型包括String, Int, Float….等可随机的类型，还包括最重要的Dictionary。 若类型是 Dictionary**(类型是字典，代表他也是一个自定义的Codable模型)，遍历里面的元素，将元素在做一次RandFactory**，并用新值更新Dictionary，达到递回。 1234for (_, variable) in dictionary.enumerated() { let factory = RandFactory(variable.value, variable.key, specificBlock: specificBlock, delegate: delegate).randData() dictionary.updateValue(factory, forKey: variable.key) } 附加功能 可以做到忽略特定变量，指定类型随机种子….等，这里不赘述 Dictionary 传成 Data 1let jsonData = try JSONSerialization.data(withJSONObject: newDicionary, options: .prettyPrinted) Data Decode 成 实例 12let decoder = JSONDecoder() let newinstance = try decoder.decode(T.self, from: jsonData) Final Example123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct Man: Codable { var name: String = &quot;&quot; var age: Int = 40 var website: [String] = [] var child: Child = Child()}struct Child: Codable { var name: String = &quot;Baby&quot; //Baby has no name yet. var age: Int = 2 var toy: Toys = Toys()}class Toys: Codable { var weight: Double = 0.0}extension Man: RandMyModDelegate { func shouldIgnore(for key: String, in Container: String) -&gt; Bool { switch (key, Container) { case (&quot;name&quot;,&quot;child&quot;): return true default: return false } } func specificRandType(for key: String, in Container: String, with seed: RandType) -&gt; (() -&gt; Any)? { switch (key, Container) { case (&quot;age&quot;,&quot;child&quot;): return { return seed.number.randomInt(min: 1, max: 6)} case (&quot;weight&quot;,_): return { return seed.number.randomFloat() } default: return nil } }}let man = Man()RandMyMod&lt;Man&gt;().randMe(baseOn: man) { (newMan) in guard let child = newMan?.child else { print(&quot;no&quot;); return } print(child.name) //Baby print(child.age) //3 print(child.toy.weight) //392.807067871094}","link":"/blog/2018/04/24/CodableModel/"},{"title":"(Xcode) 編譯器小白筆記 - LLVM前端Clang","text":"(Xcode) 編譯器小白筆記 - LLVM前端Clang 本文为笔记型式呈现，并非全部原创，来源见文末 Compiler Clang - LLVMApple（包括中后期的NeXT） 一直使用GCC作为官方的编译器。GCC作为开源世界的编译器标准一直做得不错，但Apple对编译工具会提出更高的要求。 Clang这个软体专案在2005年由苹果电脑发起，是LLVM编译器工具集的前端（front-end），目的是输出程式码对应的抽象语法树（Abstract Syntax Tree, AST），并将程式码编译成LLVM Bitcode。接着在后端（back-end）使用LLVM编译成平台相关的机器语言 。 先看结果main.m 1234567891011121314#import &lt;Foundation/Foundation.h&gt;#define DEFINEEight 8int main(){ @autoreleasepool { int eight = DEFINEEight; int six = 6; NSString* site = [[NSString alloc] initWithUTF8String:&quot;starming&quot;]; int rank = eight + six; NSLog(@&quot;%@ rank %d&quot;, site, rank); } return 0;} 直接编译成执行档 clang -fmodules main.m 产出 .out (executable) Clang (Frontend前端)是一个C、C++、Objective-C和Objective-C++程式语言的编译器前端 Clang源码结构 Clang步骤clang -ccc-print-phases main.m 1.Input (Driver)指定语言 , 架构, 输入file clang -x objective-c main.m 2.Preprocessor(预处理)import 头文件, include头文件等 ,macro宏展开，处理’#’开头指令 单做预处理, 并取得预处理结果 clang -E main.m 预处理最终结果： 12345678910111213141516# 1 &quot;/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h&quot; 1 3# 185 &quot;/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h&quot; 2 3# 2 &quot;main.m&quot; 2int main(){ @autoreleasepool { int eight = 8; int six = 6; NSString* site = [[NSString alloc] initWithUTF8String:&quot;starming&quot;]; int rank = eight + six; NSLog(@&quot;%@ rank %d&quot;, site, rank); } return 0;} 依据上面的结果能明显看到 header被换成了明确的全局位置，常量DEFINEEight也被替换进代码里，讲到import 就不得不提 modules 2.1 Modules 模块 (-fmodules) 参考 LLVM modules文档 文章里提及：Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Clang 以简单的 import std.io 概念取代 原本冗余的函数库(libraries)引进 #include &lt;stdio.h&gt;，类似java的package，目前Clang #include的机制是 编译器会去递回检查每个Header，header inculde的 header文章里提了几个弱点：Compile-time scalability：耗时编译Fragility：多引入顺序或导致宏冲突Conventional workarounds：C语言长久的息惯，导致代码较丑 Tool confusion 然而编译器在碰到import时，会直接载入module对应的二进制文件并取得他的api，一个module不依赖外部header，只编译一次，api也只解析一次，当然module也有些缺点包括 namesspace（可能重名）, 改库代码, 无法适应各种机器的Arch。 3 Lexical Analysis (词法分析 Lex, Tokenization) -&gt; .i (Tokens)此步骤是Compiler里的基本程序，将字符一个一个的读进Lexer里，并根据构词规则识别 Token(单词)，此处还不会校验语法 做词法分析并把Token分析结果展示出来 clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m 每一个标记都包含了对应的源码内容和其在源码中的位置。注意这里的位置是宏展开之前的位置，这样一来，如果编译过程中遇到什么问题，clang 能够在源码中指出出错的具体位置。 -fsyntax-only: Run the preprocessor, parser and type checking stages. 4 语法分析(Semantic Analysis) -&gt; AST语法分析，在Clang中有Parser和Sema两个模块配合完成，验证语法是否正确，并给出正确的提示。 4.1 Parser遍历每个Token做词句分析，生成一个 节点（Nodes）该有的资讯 4.2 Semantic在Lex 跟 syntax Analysis之后\b, 也就是在这个阶段已经确保 词 句 语法已经是正确的形式了，\bsemantic 接着做return values, size boundaries, uninitialized variables 等检查，之后根据当前的资讯，生成语意节点（Nodes），并将所有节点组合成抽象语法书(AST) 做 语法分析 并展示 AST clang -fmodules -fsyntax-only -Xclang -ast-dump main.m 5 抽象语法树 Abstract Syntax Tree可以说是Clang的核心，大部分的优化, 判断都在AST处理（例如寻找Class, 替换代码…等) 此步骤会将 Clang Attr 转换成 AST 上的 AttributeList，能在clang插件上透过 Decl::getAttr&lt;T&gt; 获取 Clang Attributes 是 Clang 提供的一种源码注解，方便开发者向编译器表达某种要求，参与控制如 Static Analyzer、Name Mangling、Code Generation 等过程, 一般以 __attribute__(xxx) 的形式出现在代码中, Ex: NS_CLASS_AVAILABLE_IOS(9_0) 结构跟其他Compiler的AST相同与其他编译器不同的是 Clang的AST是由C++构成类似Class,Variable的层级表示，其他的则是以汇编语言编写。 这代表着AST也能有对应的api，这让AST操作, 获取信息 都比较容易，甚至还夹带着地址跟代码位置。 AST Context: 存储所有AST相关资讯, 且提供ASTMatcher等遍历方法 Node三大Class Decl - Declarations(声明), Stmt - Statements(陈述句), type(类型) 子类过于详细不在这多写 6 代码生成 CodeGen -&gt; IR中间代码(.ll)CodeGen负责将语法树从顶至下遍历，翻译成LLVM IR，是LLVM Backend 的输入，是前后端的桥接语言。 产出IR: clang -S -fobjc-arc -emit-llvm main.m -o main.ll LLVM IR 有三种表示格式，第一种是 bitcode 这样的存储格式，以 .bc 做后缀，第二种是可读的以 .ll，第三种是用于开发时操作 LLVM IR 的内存格式。 产出Bit clang -emit-llvm -c main.m -o main.bc 查看BitCode llvm-dis &lt; main.bc | less 6.1 IR 优化 OptimizationIR提供了多种优化选项，-01 -02 -03 -0s…. 对应着不同的入参，有比如类似死代码清理，内联化，表达式重组，循环变量移动这样的 Pass。 Extra: Clang 插件使用 libclan g, clang, LibTooling 插件可以改变 clang 生成代码的方式，增加更强的类型检查，或者按照自己的定义进行代码的检查分析等等。要想达成以上的目标， reference: Clang插件了解Clang-astUnderstanding the Clang ASTAST DetailClangASThttps://clang.llvm.org/# 深入剖析-iOS-编译-Clanghttps://llvm.org/devmtg/2017-06/2-Hal-Finkel-LLVM-2017.pdf# 从Swift桥接文件到Clang-LLVM","link":"/blog/2018/11/19/Clang/"},{"title":"如何实作原生IOS热度图-CG直接做图+MapKit","text":"本教程使用Swift 3.1, Xcode 8.0 代码:https://github.com/jamesdouble/JDSwiftHeatMap 现在Iphone使用者常使用的地图插件，不外乎就是高德与百度，国外则是Google，看来看去就是没啥人在用本地端自带的MKMapView，一个原因是起步晚所以欠缺很多使用者经验跟资料，再来一个我自己认为是现成API极少，MKMapView基本上只有Annotaion,Overlay是Developer可以自订的，而百度有轨迹,雷达…等已经是现成的API。 于是我越想越不顺心，要用还是要用咱IOS原生自带的，在网上搜了一圈只看到一个用OC写的古老项目，用起来总不顺心，现在想经由开源的方法汇整大家意见来提高整体的自由度跟使用性。 热度图热度图是早期(1991)就已经出现的资料表达形式(矩阵表示)，其成熟度以及相对应衍生图像也是相对于其他的地图表达方式成熟。 前言实作起来不需要用太广的知识或是什么深不见底的技术，基本上只要熟悉两个区块： MapKit : 这个当然是必须的，毕竟我们是要建立在原生的地图上，但基本的如何新增Overlay,OverlayRender…等，这篇文章不会做太多解释。 CGContext : 也就是指Core Graphic, 这块应该是不管走到哪都会碰到的冤家，不外乎就是涂鸦着色啦～ 使用者Input利用Delegate取得资料点的经纬度、影响范围跟影响力。 HeatMap on MapKit - 记录位置MapKit该做的就是MapKit“能”做的，记录相关的地理资料，包括资料的“经纬度座标“以及距离。 MKOVeraly:很明显，热度图这样超级不规则的图形，MKCircle,MKPolyline,MKPolygon…等，并不能满足我们需要的，还是得从最根本的MKOverlay重新创造一个子类别。 计算Overlay的BoudingMapRect(涵盖范围)： 1234567891011121314151617181920212223242526/** 有新的点加进来 -&gt; 重新计算这个Overlay的涵盖 */ override func caculateMaprect(newPoint:JDHeatPoint){ var MaxX:Double = -9999999999999 var MaxY:Double = -9999999999999 var MinX:Double = 99999999999999 var MinY:Double = 99999999999999 if let BeenCaculatedMapRect = CaculatedMapRect{ //非首次计算 -&gt; 把上次计算的MapRect拿出来，比MaxX,Y MinX,Y MaxX = MKMapRectGetMaxX(BeenCaculatedMapRect) let heatmaprect = newPoint.MapRect let tMaxX = MKMapRectGetMaxX(heatmaprect) MaxX = (tMaxX &gt; MaxX) ? tMaxX : MaxX . . //每次计算新的资料点，MapRect都会变大。} else{ //首次计算 -&gt; 取第一个点的Maprecr let heatmaprect = newPoint.MapRect . . } let rect = MKMapRectMake(MinX, MinY, MaxX - MinX, MaxY - MinY) self.CaculatedMapRect = rect } 同理，现有的OverlayRender都无法满足，我们要的形状，所以也是重新定义一个类别。 draw是这个类最重要的Func，再之后Core Graphic 那段一起写。 1override func draw(_ mapRect: MKMapRect, zoomScale: MKZoomScale, in context: CGContext) 过渡(ＭapKit -&gt; Core Graphic)熟悉MapKit的朋友们一定都知道，MKMapRect与CGRect的差别，也清楚他的转换方法，通常只会在上述的**” draw “，也就是要画的时候进行转换，但我这边必须提早进行，因为我必须先知道我要画什么，所以我这里自带一个名词*[ RowFormData ]***。 使用者资料丛集转换前： 单位:MKMapRect,位置:MKMapPoint,范围:KilloMeter,原点:很大 使用者资料转换后： 单位:CGRect,位置:CGPoint,范围:CGFloat,原点:(0,0) 1234567891011121314151617181920212223242526//JDOverlayRender override func caculateRowFormData(maxHeat level:Int)-&gt;(data:[RowFormHeatData],rect:CGRect)? { var rowformArr:[RowFormHeatData] = [] // for heatpoint in overlay.HeatPointsArray { //将整个丛集转换成CGRect let mkmappoint = heatpoint.MidMapPoint let GlobalCGpoint:CGPoint = self.point(for: mkmappoint) let OverlayCGRect = rect(for: overlay.boundingMapRect) //将原点化成(0,0) let localX = GlobalCGpoint.x - (OverlayCGRect.origin.x) let localY = GlobalCGpoint.y - (OverlayCGRect.origin.y) let loaclCGPoint = CGPoint(x: localX, y: localY) //将半径转乘CGFloat let radiusinMKDistanse:Double = heatpoint.radiusInMKDistance let radiusmaprect = MKMapRect(origin: MKMapPoint.init(), size: MKMapSize(width: radiusinMKDistanse, height: radiusinMKDistanse)) let radiusCGDistance = rect(for: radiusmaprect).width //储存新的资料集 let newRow:RowFormHeatData = RowFormHeatData(heatlevel: Float(heatpoint.HeatLevel) / Float(level), localCGpoint: loaclCGPoint, radius: radiusCGDistance) rowformArr.append(newRow) } let cgsize = rect(for: overlay.boundingMapRect) return (rect:cgsize,data:rowformArr) } 计算层：将RowFormData-&gt;CGImage我们有了RowFormData后，就能开始计算什么位置放什么颜色，我们这里自创一个简易的类别，来帮助我们区隔该做的事： 这边会用到的Core Graphic并不是一般常见的UIGraphicsBeginImageContext之后，GetContext在做movePoint,addArc,addPath….等，因为要再次强调我们图层的形状是超级不规则，甚至还要计算颜色。 超级踩坑区超级踩坑区超级踩坑区我们要用的是CGContex里的建构式 参数有data,width,height,bitsPerComponent,bytesPerRow,space,bitmapInfo该怎么看呢？（对于图片概念不熟悉的朋友，我在这也扯不完，网上搜索Bitmap或Pixels还有RGB应该就很多了。） 参数只要配对错误就会报错，而且不会跟你说错哪 上图的width,height已经有了，就是刚刚计算出来的CGRect CGColorSpace &amp; BitmapInfo：这两个参数相辅相成，就是告诉它你的data会以什么样的形式呈现，以RGB或是灰阶…等，上面的图片是RGB，我们要用的也是RGB***（space = CGColorSpaceCreateDeviceRGB())***，但是多了一个值Alpha这个值大家，bitmapInfo = CGImageAlphaInfo.premultipliedLast.rawValue,这告诉它alpha直放在最后 –&gt; 也就是一个Pixel格式（R G B A) 有了Pixel格式就知道它的大小，四个值都是0~255所以是8个Bits（BitsPerComponent），一个Pixel就是8 * 4 =32Bits (4Bytes)，bytesPerRow = 4 * width。 得知Data格式是大小 (4 x width) x height的 UTF8Char(大小刚好是8bits)阵列。 回到代码： 123456789101112131415161718192021222324252627282930override func produceRowData() { var ByteCount:Int = 0 for h in 0..&lt;self.FitnessIntSize.height { for w in 0..&lt;self.FitnessIntSize.width { var destiny:Float = 0 for heatpoint in self.rowformdatas { let pixelCGPoint = CGPoint(x: w, y: h) //计算每个资料点对这个pixel的密度影响 } . . let rgb = JDRowDataProducer.theColorMixer.getDestinyColorRGB(inDestiny: destiny) let redRow:UTF8Char = rgb.redRow let greenRow:UTF8Char = rgb.greenRow let BlueRow:UTF8Char = rgb.BlueRow let alpha:UTF8Char = rgb.alpha //存入4个Byte进RowData self.RowData[ByteCount] = redRow self.RowData[ByteCount+1] = greenRow self.RowData[ByteCount+2] = BlueRow self.RowData[ByteCount+3] = alpha ByteCount += 4 } } } 有了Data回到Render123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354override func draw(_ mapRect: MKMapRect, zoomScale: MKZoomScale, in context: CGContext) { func getHeatMapContextImage()-&gt;CGImage? { //More Detail func CreateContextOldWay()-&gt;CGImage? { func heatMapCGImage()-&gt;CGImage? { let tempBuffer = malloc(BitmapMemorySize) memcpy(tempBuffer, &amp;dataReference, BytesPerRow * Bitmapsize.height) defer { free(tempBuffer) } let rgbColorSpace:CGColorSpace = CGColorSpaceCreateDeviceRGB() let alphabitmapinfo = CGImageAlphaInfo.premultipliedLast.rawValue if let contextlayer:CGContext = CGContext(data: tempBuffer, width: Bitmapsize.width, height: Bitmapsize.height, bitsPerComponent: 8, bytesPerRow: BytesPerRow, space: rgbColorSpace, bitmapInfo: alphabitmapinfo) { return contextlayer.makeImage() } return nil } if let cgimage = heatMapCGImage() { let cgsize:CGSize = CGSize(width: Bitmapsize.width, height: Bitmapsize.height) UIGraphicsBeginImageContext(cgsize) if let contexts = UIGraphicsGetCurrentContext() { let rect = CGRect(origin: CGPoint.zero, size: cgsize) contexts.draw(cgimage, in: rect) return contexts.makeImage() } } print(&quot;Create fail&quot;) return nil } let img = CreateContextOldWay() UIGraphicsEndImageContext() return img } if let tempimage = getHeatMapContextImage() { let mapCGRect = rect(for: overlay.boundingMapRect) Lastimage = tempimage context.clear(mapCGRect) self.dataReference.removeAll() context.draw(Lastimage!, in: mapCGRect) } else{ print(&quot;cgcontext error&quot;) } } 写到最后发现自己的演算法有点凌乱，写这篇文章也是希望能有人能参与这个reop，改进整个效能，整个过程浓缩就是 MKOverlay -&gt; CGImage。","link":"/blog/2017/07/15/HeatMap/"},{"title":"SpriteKit - 實做虛擬搖桿","text":"本文适合SpriteKit初心者 源码：https://github.com/jamesdouble/JDGamePaddle 虚拟摇杆16年，MOBA手游市场打得可火热（这里咱不帮任何游戏背书），撸瑟如我也是在16年开始玩SpriteKit，也就是苹果自制的2D游戏框架。有玩过MOBA手游的，一定十分熟悉游戏里我们是如何移动主人公的吧？没玩过的……咱们不啰唆，先上图。 这样想不起来的也想起来了呗，因为SpriteKit本身并没有提供像摇杆这样元件(有提供反而奇怪)，为了以防朋友们采坑(也没有很多坑)，我就写了一个简易的摇杆Lib，SKScene,SKView(SpriteKit的UIView), UIView皆可直接加上。 简单的出发一开始若把问题想得太复杂，那歪路肯定会走的特别的多，我们就照着上面的图来刻吧，外面一个圆圈，嗯，里面一个小圆…..好，结束了 ，就从拉出两个圆来出发吧！！ 组件1:SKShapeNodeFor SpriteKit初心者：UIKit里每个元件几乎都是UIView的子类别，而SpriteKit里的每个元件几乎都是SKNode的子类别。 那SKShapeNode又是什么？它是SKNode的子类别，若是你不是要用图片来初始化一个物件而是纯几何形状或是线条的话，使用它来做Node会快上许多，看它的建构值就能知道，真的很“几何”。 来吧！第一步！两个圆形！ 12345MovingPing = SKShapeNode(circleOfRadius: paddleSize.width * 0.18)MovingPing?.fillColor = UIColor.black //内圆黑色实心PaddleBorder = SKShapeNode(circleOfRadius: paddleSize.width * 0.5 )PaddleBorder?.fillColor = UIColor.clear //外圆中间空心PaddleBorder?.strokeColor = UIColor.black 组件2：点击、滑动Hmm…. We almost here, right? 不过现在你不管怎么拨弄它，它都不会移动的，在SpriteKit里常做的处理点击方式是实作覆写UIResponder大家常见的Method。 1234567891011121314151617181920212223override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) { let touch = touches.first! touching = true let position = touch.location(in: self) if((PaddleBorder!.contains(position))) //若是手指还在边界内 { MovingPing?.position = touch.location(in: self) //内圆移到手指位置 } didMove() } override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) { let touch = touches.first! let postion = touch.location(in: self) if((PaddleBorder!.contains(postion))) { MovingPing?.position = postion } /* 略 */ } 结束了吗？执行起来试试吧。看起来听生硬的对吧，若是有MOBA手游只做到这边，主人公一定是脚抽了筋。会发生这样的杯具是在touchesMoved只判断是否手指在外圈内，而忽略了若是使用者从内圈滑到外圈的情况。 让我们把上面那段注解换成 1234567891011121314151617 else{ movingpaddleSmoothly(position: postion) }//算出边界外手指跟中心连成一线后，跟边界的交点。 func movingpaddleSmoothly(position:CGPoint) { let centerPoint = PaddleBorder!.position let radius = self.frame.width * 0.5 var distance:CGFloat = 0 let diffx:CGFloat = (centerPoint.x - position.x) * (centerPoint.x - position.x) let diffy:CGFloat = (centerPoint.y - position.y) * (centerPoint.y - position.y) distance = sqrt(diffx + diffy) let ratio:CGFloat = radius/distance let newPostition:CGPoint = CGPoint(x: position.x * ratio, y: position.y * ratio) MovingPing?.position = newPostition } 最后我们再每次移动摇杆时，回传一个经过正规化的CGVector出去给委任，以便使用者能随着滑动摇杆，做出适当的回应。","link":"/blog/2017/01/06/SpriteKit_GamePaddle/"},{"title":"如何刻出一个可拖动的导航浮動按钮","text":"本篇教程使用Swift 源碼:https://github.com/jamesdouble/JDJellyButton，以下稱JDJellyButton 0)何謂導航浮動按鈕 当你的应用开发到一定程度的规模时，必须要有个十分清晰明了的导航功能，才不会让使用者卡在某一页，不知道如何前往他们想去的页面。常见的导航方式，不外乎最常用UITabBarController、UINavigationBar，另外有一种虽然常见，但是因为不是IOS原生就有的UIControl，所以还是比较少人使用，那就是 “floating navigation button“。之所以会有**’Floating’**这个字眼，是大多这样的导航按钮会凌驾在所有视图控制器(UI…ViewController)上，不管底下的视图控制器如何切页他都会保持在同样的位置。 0.1)JDJellyButton特色：按鈕群組源碼其中一個特色就是浮動按鈕附有群組的功能，能讓一個浮動按鈕能包含更多的子按鈕以處理更多不同的事件。 0.2)UIView or UIButton?大部分的按钮控件虽然都是‘按钮’，但是比起继承实作UIButton,还不如继承实作他的父类别UIView, 可做的事比较多，限制也比较少，本文的JDJellyButton继承自UIView。 0.3)Gesturer or UIResponder因为我们是自己实作继承UIView的类别，比起每个按钮都要加上手势，我比较偏好在类别下实作几个常见的UIResponder方法 - touchesBegan, touchesMoved。一来省去还要宣告selector这样拐个弯的做法。 1)代碼架構＆解析 以下是JDJelllyButton的元件，我將由底層的子元件往上講解。 123456var MainButton:JDJellyMainButton!var Container:JelllyContainer!var RootView:UIView?var delegate:JellyButtonDelegate?var _datasource:JDJellyButtonDataSource?var jellybutton:JDJellyButtonView? 1.1)ButtonGroups紀錄了多個JDJellyButtonView跟它們個別的位置，此為“一組”Button 1234struct ButtonGroups { var buttongroup:[JDJellyButtonView]! var groupPositionDiff:[CGPoint]?} 1.2)JDJellyButtonView:UIView此一类别是实作每个按钮的基础样式与点击，一个圆配一张图片。别忘了要处理点击的事件。我做的方法是通知委任（上层接口JDJellyButton）被点击的是第几的Group的第几个Button。 123protocol JellyButtonDelegate { func JellyButtonHasBeenTap(touch:UITouch,image:UIImage,groupindex:Int,arrindex:Int)} 12345678override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) { let image = self.imgView?.image let groupindex = dependingMainButton?.getGroupIndex() let arrindex = dependingMainButton?.getJellyButtonIndex(jelly: self) print(&quot;\\(groupindex),\\(arrindex)&quot;) tapdelegate?.JellyButtonHasBeenTap(touch: touches.first!,image: image!,groupindex: groupindex!,arrindex: arrindex!) } 1.3)JDJellyMainButton:JDJellyButtonView本控件最主要的类别，也是整个导航浮动按钮的主体。样式跟其他的按钮一样，差别是在点击后的事件以及它可以拖动，所以就直接继承JDJellyButtonView并且覆写touchesBegan, touchesMoved，并且也由它来管理ButtonGroups。 12345678910111213141516171819func appendButtonGroup(bgs:ButtonGroups){ var temp_bgs:ButtonGroups = bgs for jelly in temp_bgs.buttongroup { //让每个按钮知道自己依附的是谁 //因為只有MainButton知道子Button位在第幾個Group jelly.dependingMainButton = self } temp_bgs.groupPositionDiff = [CGPoint]() for i in 0..&lt;bgs.buttongroup.count { //计算位置 let cgpoint:CGPoint = CGPoint(x: x[i] , y: y[i]) temp_bgs.groupPositionDiff?.append(cgpoint) } buttongroups.append(temp_bgs)} 需要注意的是因为JDJellyButton有分群组，而触发的条件是“长按”，因此我们不再touchesBegan做立即展开，而是在touchesEnded处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) { /* 略 */ if(Expanding) { expandignMove = true closingButtonGroup(expandagain: false) } //紀錄點下去的時間 LastTime = touches.first!.timestamp /* 略 */ }override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) { /* 略 */ //短按 if(touches.first!.timestamp - LastTime! &lt; 0.15){ if(!Expanding) { expandButtonGroup() } else { closingButtonGroup(expandagain: false) } } else //長按 { if(!Moving) { switchButtonGroup() } if(expandignMove &amp;&amp; Moving) { expandButtonGroup() } } Moving = false expandignMove = false /* 略 */ } 1.4)JelllyContainer:UIView本来并没有打算制作这个类别，后来遇到了一个非常严重的问题：虽然按钮以外透明的地方看似可点击后方的其他View，但是其实会点到浮动导航按钮的整个背景，进而无法触发后方使用者原本的东西。上网爬了之后，发现需覆写point这个Function。 12345678override func point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool { for subview in subviews { if !subview.isHidden &amp;&amp; subview.alpha &gt; 0 &amp;&amp; subview.isUserInteractionEnabled &amp;&amp; subview.point(inside: convert(point, to: subview), with: event) { return true } } return false }","link":"/blog/2017/01/05/JellyButton/"},{"title":"向Hero致敬與分析-(一)","text":"向Hero致敬與分析-(一)0)Who is Hero?其实我一直都十分钟意有关强化UI功能或是做一些过场动画的开源库，最近在网上出现一款非常火的过场动划开源库，短短几天内就4000+ Strar，它的名字也十分的好记，就叫 *”Hero”*。 https://github.com/lkzhao/Hero 本文撰写前，已知会作者 0.1)对此英雄的第一印象其实Hero真正吸引我的是他精美的文案，如Hero它是Foucus在两个UIViewController之间的UIViewControllerAnimatedTransitioning，也就是两个UIViewController切换时的过场动画，而以下是它针对他的功能提供的示意动画： 很简洁又一目了然。 1)Hero’s Show #1 - Simple Present咱们废话不多说，直接让各位客官来看咱英雄大爷最基本的能耐。 这样的过场需要几行程式码呢？ View Controller 1123456blueView.heroID = &quot;blue&quot;purpleView.heroID = &quot;purple&quot;greenView.heroID = &quot;green&quot;/* Label同理*/ View Controller 212345678isHeroEnabled = trueblueView.heroID = &quot;blue&quot;purpleView.heroID = &quot;purple&quot;greenView.heroID = &quot;green&quot;/* Label同理*/ 长话短说，Hero在两个UIViewController切换之间，将前控制器里ID a的物件位置移到后控制器同为ID a的物件位置。而我们将要探讨的即是这个“切换”中间，作者是如何实作的。 1.2)Present 流程 1.2.1)Hero为Transitioning做准备 Hero:UIViewControllerTransitioningDelegate animationController:这里它做的事很简单就是把来源VC与目标VC做保存的动作，以便日后取用。 123456func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? { self.presenting = true self.fromViewController = fromViewController ?? presenting self.toViewController = toViewController ?? presented return self } interactionControllerForPresentation:这个方法若不是回传Null则需自己实作UIViewControllerInteractiveTransitioning处理相关参数，若是Null则代表非InterActiveTransition。 InterActiveTransition:最经典例子在有NavigationController的情况下手指从荧幕最左端往右滑动，可以看到上层VC，在还没完全放开的期间还可以左右滑动，甚至能放回去不做POP。 Hero: UIViewControllerAnimatedTransitioning animateTransition:这个部分可以说是整个Hero的起源，也是在做VC的过场动画时，一定会做到的部分。为了明确表达这支function，本篇只先提到Context，其余将在第二篇续谈。 123456789101112public func animateTransition(using context: UIViewControllerContextTransitioning) { //transitionContext 会在 end 释放 if transitionContext != nil { return } transitionContext = context /* 略.*/} 在官方文档里明确地提到不建议实作此类别，以免破坏原本系统自己传递的Context。Hero也只是单纯将其记下来。 UIViewControllerContextTransitioning:若要用一个词来概括它， 应该就是『上下文』吧，就好像Transition是介于两个句子(VC)间的逗点，而Context即记录了上下两句的语意。里面记录了与此过场相关的控制器、画面(view)、以及如何过场（style) 第二篇：http://www.jianshu.com/p/a7012ec2c5e5","link":"/blog/2017/01/10/Hero_part1/"},{"title":"WebView如何处理不受信任的http网路凭证","text":"WebView如何处理不受信任的http网路凭证本篇使用Swift 并附上官方文档前阵子接了（公司Ａ）一个专案，再加上要毕业了，学校各种忙碌，距离上一篇文章也有好大一段时间…，也是因为这个专案碰到了些小问题，才想来写写笔记。 一、起因公司Ａ有个只限内网用的公文系统（似乎是用java写的网页?），到目前为止都是单纯在Windows上的小程式利用『URL Scheme』跟这个系统互相丢接资料，我则是要负责写一个IOS App 跟此系统做一样的事。但我是承包的，无法在公司Ａ的内网下测试，经过一番讨论，他们决定将系统做个测试用的灌在windows虚拟机上，我在Mac上执行就等于我跟这个系统相同内网。 二、前置测试 🖥️假设各个内网ip如下： (A)Mac：192.168.1.1 (B)Mac上的Windows虚拟机:192.168.1.2 (C)实机Iphone：192.168.1.3 (D)系统网址：https://192.168.1.2:8888/Domain A ping B,C -&gt; OK 👌、 B ping A,C -&gt; OK 👌 A 预览 D -&gt; OK 👌、 B 预览 D -&gt; OK 👌 接下来让我们看看我要说的 C 预览 D 的状况 三、问题一 (UIWebView 预览 D) 🤔 第一种尝试是利用WebView, 为什么首选它呢？ 因为业主不希望在两个App之间做过多的切换(一整个流程下来可能跳转两~三次），也不希望使用者在下次开启Safari时，还停留在系统的页面。 NSURLErrorDomain: -1003？ WebView就在我LoadRequest时跳出这么一个错误，看到ErrorDomain时，我也没有多想，就直接认为应该是我DNS没设定好之类的问题，于是又重开了虚拟机，重启站台...!@#!$🙄🙄 Safari可开启？ 会突然使用Safari是因为我不想一直重新Build，内心想说结果一样，没想到，跳出来一个这样的提示： 按下”Continue”后，就显示出系统的页面了！ 不信任的的凭证 有了这个弹窗的提醒，我才明白问题的症结点原来是“凭证”，原来是之前IOS9的新设定：App Transport Security (ATS) ATS参考网址：https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33 基本上ATS就是为了要确保你的App更安全，会挡两样东西一个就是没有Security的Http一个是不信任凭证的Https，不会无意间跑到钓鱼网站之类的。 三、问题一解法📖 设定Info.plist 第一个方法最简单就是直接关掉ATS，直接在Info.plist增加以下其中一对Key Value Pair 1.Allow Arbitary Loads （NSAllowArbitrayLoads) 用途是？解除所有连线的ATS限制，这里指的所有连线包括URLRequest,URLConnection,URLSession,UIWebView....等。 但是官方文件里也很表明写了，只要Allow Arbitary Loads这个值被设为True，就没有办法通过上架审核，所以我不采用此方法。 2.Exception Domain （NSExceptionDomains) 用途是？排除某个Domain使其不受ATS的限制。 个人认为这个Key比较适合拿来使用，如果你明确知道自己会在某个Domain之下的话。 这个Key我不知道会不会影响上架？ 官方文档：https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW35 HTTPS Server Trust Evaluation https://developer.apple.com/library/content/technotes/tn2232/_index.html#//apple_ref/doc/uid/DTS40012884-CH1-SECWEBVIEW 另一种方法就是实作官方文档里的『Trust Customization for Specific APIs』，也就是自定义某个要求的凭证检查 1.URLSession 依照官方文档，我们需要实作 urlSession(_:task:didReceive:completionHandler:)，如果凭证无法验证，会发出一个Challenge供你判断你要拒绝这个连线还是提供一个凭证来解决： 遵守URLSessionDelegate 1let session = Foundation.URLSession(configuration: sessionConfig, delegate: self, delegateQueue: nil) 处理 - **『Challenge』** challenge : URLAuthenticationChallenge Challenge这个词并不是ios或CocoaFrameWork才有的，而是互联网中伺服器向使用者端发出的『**Challenge–response authentication**』，是一个用来验证用户或网络提供者的协议，会要求使用者回传一些资讯，帐号、密码、凭证...等，在下面会说说有哪些。 &gt; https://developer.apple.com/reference/foundation/urlauthenticationchallenge &gt;https://zh.wikipedia.org/zh-cn/CHAP 12345678910111213141516 func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Swift.Void){ //1 let protectionspace = challenge.protectionSpace //2 let authMethod = protectionspace.authenticationMethod if authMethod == NSURLAuthenticationMethodServerTrust { //3 let credential = URLCredential(trust: challenge.protectionSpace.serverTrust!) //4 let input:URLSession.AuthChallengeDisposition = .useCredential //5 completionHandler(input, credential) }} 1.***Challenge.protectionSpace*** : URLProtectionSpace -&gt; 包含了这个 authentication request的host,port...等，让你判断该用什么**credential（证书）**应付。 2.***authenticationMethod*** ： 这是我刚刚提到的，伺服器要求认证的方法，这个方法就会决定接下来要做的事，像是：NSURLAuthenticationMethodHTTPBasic:要求使用者回传帐号跟密码，而我们要处理的是NSURLAuthenticationMethodServerTrust，要求使用者回传一个凭证。 3.***URLCredential*** : 这个类有几种差异满大的Init()，主要就是看authenticationMethod来决定你要回传的是什么。 ![](https://jamesdoubleblogphoto.oss-cn-shanghai.aliyuncs.com/iOSBlog/ArticleImages/2019/15770897288708.jpg) 我们这次要做的是凭证的处理，所以用第二个建构。 &gt;https://developer.apple.com/reference/foundation/urlprotectionspace/nsurlprotectionspace_authentication_methods 4.URLSession.***AuthChallengeDisposition*** : 表示行为，包括要使用凭证、取消此次要求、执行预设动作...等列举，我们要用凭证所以用.useCredential。 5.利用completionHandle告知结果：（使用凭证,这个凭证） 2.UIWebView - 回归正题我们要用UIWebView，但官方文档即提到无法自定义Https server trust，但我们还是要用上面的方法解决。 棘手的地方是UIWebView只能单纯LoadingRequest跟管理URLSession，必须绕道而行。 实作UIWebViewDelegate记住失败的Request，并且建立一个URLConnection。 1234567891011121314 func webView(_ webView: UIWebView, shouldStartLoadWith request: URLRequest, navigationType: UIWebViewNavigationType) -&gt; Bool{ LastRequest = request return true} func webView(_ webView: UIWebView, didFailLoadWithError error: Error){ FailRequest = LastRequest if(FailRequest != nil) { let _:NSURLConnection = NSURLConnection(request: FailRequest! , delegate: self)! }} 虽然刚刚讲的是URLSession，但两个用法其实是相同的，所以我们遵守NSURLConnectionDelegate，并在最后重新Loading一次Request，这样同个Request就可以通了。 12345678910111213 func connection(_ connection: NSURLConnection, willSendRequestFor challenge: URLAuthenticationChallenge) { if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust { print(&quot;send credential Server Trust&quot;) let credential = URLCredential(trust: challenge.protectionSpace.serverTrust!) challenge.sender!.use(credential, for: challenge) } else{ challenge.sender!.performDefaultHandling!(for: challenge) } connection.cancel() SystemWebView.loadRequest(FailRequest!)}","link":"/blog/2017/06/06/WebViewVerify/"},{"title":"深入淺出 Xcode Command Lines Tool(1) - 初探","text":"Xcode命令列 = Xcode Command Lines Tool 如果你是一個iOS/Mac Developer 或是你在用Mac開發什麼壞壞的事 你一定對這個畫面不陌生， 然後我們只需要按下安裝， 之後就能繼續開發啦！ 本文結束.... Ok, 所以…. 這個Dialog到底幫我們安裝了什麼？ 安裝在哪？ 為何要安裝？ 安裝了什麼如彈窗所說 命令列開發者工具 (command line developer tools)，可以從Apple Developer單獨下載 有macOS SDK, LLVM編譯器, linker…等開發環境， 我們之後再來仔細地看看裡面的內容。 這裡有一篇官方對常見關於Xcode Command Line發問做的FAQ Building from the Command Line with Xcode FAQ 安裝在哪為了得知安裝的路徑，我們使用 SuspiciousPackage 查看下載dmg裡的.pkg 哦！ 所以 Command Line Tools 在mac的 唯一路徑 就是 /Library/Developer/CommandLineTools !!! 仔細看看上上張圖的描述 - 如果你是用Xcode, Xcode 是自帶 Command Line Tools的 (老的Xcode是不默認安裝的) 那放在 Xcode 的哪呢？？ Xcode.app/Contents/Developer 目錄結構基本類似於安裝在 Library的目錄結構，但是多了不少東西， 我們會在之後提到他們 多份 Command Line Tools那.. 如果說我有多份的 Xcode 哪就有多份的 Command Line Tools ?? 😱 基於目前的討論，你的 mac 開發環境可以是以下這樣的 於是就有了三連問，現在使用的是哪一個？我該用哪一個？怎麼切換成另一個？ Xcode-SelectTo answer your question. I bring you xcode-select 作為一個command指令，名稱還是挺淺顯易懂的，也許你並不陌生。來讓我們敲個 man xcode-select 瞅瞅👀 描述內容簡述如下 xcode-select 管理著 xcode的Developer Directory你能輕鬆得使用 xcode-select –switch 在多個版本的Xcode之間切換對應的開發工具路徑，而這些路徑將被用於 xcrun, xcodebuild, cc … xcrun, xcodebuild，這又釣出了許多熟悉不過的指令，我們一樣後面說。 xcode-select用法： -s &lt;path&gt;, --switch &lt;path&gt;: 將路徑指向某個Command Line Tools, ex: xcode-select --switch /Applications/Xcode.app -p, --print-path: 打印目前指向的路徑, ex: /Applications/Xcode.app/Contents/Developer -r, --reset: 將之前用-s 指定的路徑重置, (筆者是指回application裡的xcode) --install: 彈出安裝Command Line Tools視窗，對 還是它 上面描述提到xcodebuild..等指令用的環境是基於xcode-select指向的路徑，xcode-select提供了一個環境變量，讓你能臨時使用其他環境來執行xcode command. 1env DEVELOPER_DIR=&quot;/Applications/Xcode-beta.app&quot; /usr/bin/xcodebuild xcode-select的好處有了這個機制，我們就能同時擁有多個開發環境，不同的Swift版本, 不同的模擬器版本…而我們編譯的指令不需要用 /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild 只需要統一用 xcrun xcodebuild。 xcode-select in Xcode你可以在 Xcode -&gt; Preference -&gt; Locations 去選擇自己得 Command Line Tools， 在這裡選擇 效力等同於 xcode-select, 所以也是需要user密碼。 為何要安裝 Command Line Tools現在你知道 command Line Tools ‘大概是哪些東西’, ‘放在哪些地方’ 當然你可能也已經知道許多tool的用途，例如很熟悉的xcodebuild，但既然我都從頭講了，就講全一點 😅😅 For Xcode 就像大部分的軟件一樣，我們看到的,操作的都是軟件的GUI，而Xcode的底層對應的就是Command Line Tool, 例如按下 Build鍵 =&gt; xcodebuid …, 開一台模擬器 =&gt; simctl …，當然這些都不是一對一的映射，而是多個command 的組合。 我們之後會介紹幾個常見的組合。 For others然而就算你不是使用Xcode開發，還是會碰到需要安裝Command Line Tools的情況(也就是使用安裝在/Library/Developer/CommandLineTools的那組)，因為Tools也有包含整個MacOS的SDK還有編譯器Clang甚至包括Make。 例如有使用Homebrew在管理package的一些python開發或是js的開發，都會提示需要Xcode Command Line Tools. Futher More現在我們知道 Command Line Tools 是什麼，安裝在哪，以及Command Line Tools 有多個。 之後的一系列文章我會來介紹 Command Line Tools裡，確切包含了哪些命令列工具 – 深入淺出 Xcode 命令列(1) - 初探深入淺出 Xcode 命令列(加餐) - libxcselect.dylib","link":"/blog/2019/12/19/xcCmdLine-1/"},{"title":"年轻人，听说你想使用Framework - 基礎觀念","text":"Frameworks 本文為譯文，並已取得作者Nick Teissler同意。原文鏈接：原文 本文章適合初學Framework的讀者。 前言Apple 已經將 iOS, macOS 的代碼分成 Modules, libraries, frameworks。 Frameworks 的設計不單單只是為了封裝資源跟模塊化代碼，更不只是為了減少代碼的重編譯時間而已。 要想減輕代碼量、加速Debug、增加代碼復用性，就不能只知道Framework是一個可以拖來拖去的工具箱，必須更近一步的了解這些： 靜態庫 - Static Libraries 動態庫 - Dynamic Libraries Framework的結構 Linking 鏈接 與 Embed 嵌入的不同 Q &amp; A 以下內容適用 macOS, tvOS, iOS. 可能會隨時間有改動。 靜態庫 Static Libraries在靜態庫之前，我們要先從Object File說起，以基礎的角度來說，object files 就是個有結構的位元塊。這些位元塊包含著一些程序代碼、有些包含著準備給Linker跟Loader使用的資料結構。 可以試著在終端輸入以下指令，瞄一眼objectfile的樣子 1objdump -macho -section-headers /bin/ls Objectfiles通常以四種形式登場 Relocatable: 包含可以在編譯時可被其他Relocatable Link的代碼和數據，以共同製作成Executable。 Executable：準備好載入記憶體的可執行檔。 Shared: 一種特殊的Relocatable file，概念類似 動態庫。 Bundle: 我們不特別描述Bundle, 在macOS上通常當作插件使用。 譯文外補充:Relocatable:包含著能與其他relocatable在編譯時進行Linked的代碼(執行代碼)以及數據(變量全局數據)。Shared: 編譯時只依Header作api上的確認，不包進任一Executable，共享於Executable之間。 若你嘗試編譯一段沒有 main函數的 C 代碼，會得到一個 relocatable object file fancy.c 123456void fancySwap(int *xp, int *yp) { if (xp == yp) return; // try it! *xp = *xp ^ *yp; *yp = *xp ^ *yp; *xp = *xp ^ *yp; } 在Terminal輸入 1cc -c fancy.c 產出的 fancy.o 是一種 objectFile ，包含著 fancySwap 符號以及對應的實現。為了更方便地處理 Relocatable object files，多個object files能被封裝成 .a (a 代表著 archive) .a 檔也被稱作 靜態庫(static library) 或 靜態歸檔(static archive)。 當executable中某function 或 數據來自於 .a，linker是能夠智能地只鏈接其對應的符號，但是，linker還是會將所有的這些.a裡的代碼給一個固定的load地址並包含(copies and relocates)進executable中，造成肥大的executable，且增長讀進memory的時間。 當你有10個應用使用此靜態庫，就需要個別有一份copy，也就是十個復本！而且若是靜態庫的開發者更新了代碼，則所有的應用都必須重新編譯一遍。而動態庫就是為了解決這一步便利性而誕生的。 動態庫 Dynamic Libraries動態庫 (也稱作Shared Library, Shared object, 動態鏈接庫)， 跟靜態庫一樣是多個object files封裝起來的，不一樣的是動態庫只有在程序的載入時間(load time)或運行時(Run time)會被載入，並且在memory隨機的配發一段地址。 以上行為是由動態鏈接器(Dynamic linker, macOS稱dyld)來完成，動態庫在： macOS上 以 .dylib 存在 windows上 以 .DLL 存在 linux上 以 .so 存在 然而在運行時進行才做鏈接其實是一個笨重的負擔，應合理安排哪些庫需要Load以及時機。 在 Treminal輸入以下指令查看更多關於動態載入的內容 1man dlopen Shared object 解決了前面static object files的問題 現在多個executable只動態鏈接到 動態庫的『唯一』拷貝。 更新庫並不影響executable 庫的依賴會被自動載入且鏈接\b（依賴庫必須在search path裡） macOS 大規模的使用shared libraries，可以前往路徑 /usr/lib文件夾查看系統的動態庫。 如果你想要使用自己的動態庫，必須確保它被 embedded 進你的App裡。 看完上面這段，你可能會想 “太好了, 我不需要重編譯了，但我最好為我庫的使用者提供兼容性”。 是的沒錯，你的確需要考慮每當你update動態庫時，API的兼容性，或許這也是你正在看這篇文章的原因.. 學習一種具有地址兼容性的bundling格式 - Framework Framework一個Framework其實就是一個有著特定結構的文件夾裝著各種共享的資源。 這些資源通常是 圖片、Xibs、動態庫、靜態庫、文檔…等，他們被封裝成bundle存儲卻又不像其他的bundles( 像是 .app)，Framework毫不掩飾的表明它純粹就是一個文件夾。 這裡指的Bundle並不是上面所提及的Bundle Object Headers這文件夾包含了Framework對外公開的C &amp; Obj-C headers，Swift 並不會用到這些Headers，如果你的framework是用Swift寫的，Xcode會自動幫你創建這個文件夾以提供互用性。 若你有時不清楚在Swift代碼裡加 @objc, @objcMembers 的影響，可以查看 Build Settings 裡“SWIFT_OBJC_INTERFACE_HEADER_NAME”所指的文件，並試著改動@objc @objcMembers的宣告，看看這些改動對這文件的影響。 Modules這文件夾包含了LLVM, Swift 的 Module信息。 .modulemap檔案是給Clang使用的。 關於Clang 可看譯者的另一篇文 LLVM前端Clang .swiftmodule 文件夾下的檔案類似headers，但是不像是 headers, 這些檔案是二進制的且“無格式也有可能會改變”，在你Cmd-click 一個Swift函數時Xcode就是利用這些檔案去定位其所屬的module。 儘管這些都是二進制文件，但他們仍是一種叫 llvm bitcode 的結構，正因如此，我們能用llvm-bcanalyzer and llvm-strings取得相關信息。 MyCustomFramework雖然他被finder標註成Unix executable，但他其實是一個 relocatable shared object file Resources本地化的資源, xibs, 檔案, 圖片… 跟其它資源存放在這 圖片裡的箭頭 (Framework版本)這些箭頭都是 symlink 符號連結(捷徑)。 每當產生一個新版本時，會被放進 Versions/B. Current 的箭頭會被更新成指向 B。 與此同時，原本動態鏈接到A的程序仍會保持鏈接A而不是Current，怎麼辦到的？ 每當executable 在編譯時， dynamic linker會紀錄與自己有兼容的Framework路徑。 But 現今Apple已鮮少使用這個功能了 Xcode 裡 Linking vs. Embedding Frameworks這裡我們來討論Xcode裡一些常見的設定，Target的 general settings. 通常需要使用Framework時，都會選擇 “Linked Frameworks and Libraries”，除非你打算在 runtime的時候才做鏈接跟載入(前面提及的dlopen)。 Linking 和 Embedding 的差別是什麼？ 為什麼當你Embed一個Framework時，Xcode自動將Framework加到Link區？ 想一下剛剛在讀過的，dylibs儲存在哪？當你想要用自己的dylib時該做什麼？ 是的！Embedding 實際上將Framework拷貝一份到你的application bundle裡Frameworks文件夾下， 系統庫是 iOS 和 macOS 自帶的，你可以放心的鏈接他們，但是你自己的Framewroks並不是系統自帶的，因此你必須要embedded 到 application bundle裡。 而你的應用若是沒有Linking它也沒有任何用，所以Xcode自動幫你做了鏈接。 ★★ Linking and embedding間接的暗示 動態 或是 靜態鏈接， 我們現在知道embedding一個靜態庫是不合理的，因為靜態庫的符號已經被編譯進executable，所以 Xcode不會應讓你將static library放到 Embed裡 (但其實Xcode會讓你放，然而這是很沒效率的使用，所以你不該這麼做） 技術上來講，macOS是可以讓你在runtime時去載入一個靜態的 .a file的，並標記一塊記憶體當作是 executable， 這樣做能有效的載入靜態庫，然而這技術是由 JIT compilers完成的，iOS並沒有標記記憶體的能力。 ★★ 聽說你想要使用 Framework在你使用Framework或是將自己的代碼做成Framework時，有哪些因素要考慮的？ 你要開發一組應用嗎？如果是，這就是Framework本質的一部分 - 分享 Frameworks，你需要去建一個包安裝器把 shared frameworks放進 /Library/Frameworks or ~/Library/Frameworks. 你的多個apps共享著些許的重複代碼嗎？使用framework或許不是最好的選擇，如果只是要共享一個非常小量的代碼，為了保持同步的 打包和版本控制反而會成為負擔。 你想試著模塊化你的代碼嗎？如果你想要將代碼移進Framework並將它變成模組，最好注意 Swift’s access control. 別將Framework當作能不重新編譯的萬靈丹，有些項目會將代碼中極大量快完成的部分移動到Framework以提升編譯速度，這樣做的確能降低時間，如我們所知Framework不需重新編譯，然而這樣的方式會使模塊更複雜，Debug, 測試難度提升。 你要將代碼做成第三方包給其他人使用嗎？這情況下，你可以選擇使用動態庫 靜態庫 或Framework。macOS, iOS已逐漸習慣動態Framewrok了，因為他的輕便性、普遍以及易用性。 Sources John Levine’s “Linkers and Loaders” https://www.iecc.com/linker/ Bryant, R., OHallaron, D. R., &amp; S., M. (2016). Computer systems: a programmers perspective. Harlow, Essex: Pearson. “[swift-users] Where to read about *.swiftmodule file format?” https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20171127/006660.html “Dynamic-Library Programming Topics: Run Path Libraries” https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPFrameworks/Tasks/CreatingFrameworks.html#//apple_ref/doc/uid/20002258-106880 “Pew Pew the Spells: Static and Dynamic Libraries” https://pewpewthespells.com/blog/static_and_dynamic_libraries.html “Dynamic Library Programming Topics: Using Dynamic Libraries” https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/UsingDynamicLibraries.html#//apple_ref/doc/uid/TP40002182-SW10 “Apple Technical Note: Embedding Frameworks in an App” https://developer.apple.com/library/content/technotes/tn2435/_index.html#/apple_ref/doc/uid/DTS40017543-CH1-EMBED_IN_APP_SECTION “Swift and Objective-C in the Same Project” https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html “Framework Programming Guide: Installing Your Framework” https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPFrameworks/Tasks/InstallingFrameworks.html#//apple_ref/doc/uid/20002261-97286","link":"/blog/2018/12/12/frameworkEasy/"},{"title":"UICollectionViewLayoutInvalidationContext性能优化 详细流程图 + 范例","text":"起步基础 UICollectionViewLayout 基本使用 UICollectionViewLayoutAttributes Attributes赋值这里泛指了以下两个主函数，就不在赘述两个功能，以及 UICollectionViewLayoutAttributes 需处理的变量。 1234567891011class AutoSizingLayout: UICollectionViewLayout { override func prepare() { super.prepare() } override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? { return attributes }} Without Invalidating先来看看在 没有需要重新改变Attributes 下的流程(以下简称 配置流程)： data reload时，prepare计算一次，layoutAttributesForElements调用多次直到，系统已经有所有IndexPath的atrribute，就不会在调用这些functiom，直到collectionView reload。 With Invalidating现在我们把失效的概念加进来 强制失效 UICollectionViewLayout.invalidateLayout()invalidateLayout()可随时呼叫，他会将所有系统已取得的 Attribute 全部标记为 invalid 并舍弃。 准确的update时机并不是调用后，而是在下一次 layout 的 update Cycle里后，重新调用prepare. 堆栈如图： https://developer.apple.com/documentation/uikit/uicollectionviewlayout/1617728-invalidatelayout 若有overrider此方法，必须call super.invalidateLayout() 条件失效 UICollectionViewLayout.shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -&gt; Bool https://developer.apple.com/documentation/uikit/uicollectionviewlayout/1617781-shouldinvalidatelayout 默认回传 false。 overrider后，可借由传入的 newBounds 判断是否需要 invalidLayout，若回传 true 则跟 InvalidateLayout()之后的流程(堆栈)相同。 例如内容下半部，需要不断更新Attribute 1234567override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -&gt; Bool { guard let collectionView = collectionView else { return false } if newBounds.maxY &gt; contentSize.height / 2 { return true } return false} newBounds: CGRect 此bounds的触发时机，为collectionView可视范围改动时(contentOffset Change) 为了简化流程图，我们将固定一起出现的这几个步骤，划成一个： UICollectionViewLayoutInvalidationContext (以下简称 InvalidationContext)https://developer.apple.com/documentation/uikit/uicollectionviewlayoutinvalidationcontext 这的context跟出现在其他地方的Context上下文概念差不多，先借由一个function的参数，对此上下文进行设置，回传后再下一个function对设置的内容进行处理。 基于系统『原生』的 InvalidationContext 失效layout 这里再多覆写了两个函数 invalidationContext(forBoundsChange:) 可以借由参数 bounds 对context 进行部分逻辑处理，也可在这做 『失效标记』 https://developer.apple.com/documentation/uikit/uicollectionviewlayout/1617781-shouldinvalidatelayout 12345override func invalidationContext(forBoundsChange newBounds: CGRect) -&gt; UICollectionViewLayoutInvalidationContext { let invalidationContext = super.invalidationContext(forBoundsChange: newBounds) return invalidationContext} invalidateLayout(with:) 根据上一部处理好的逻辑或 『失效标记』 做属性处理，必调用super.invalidateLayout(with: invalidationContext) 123override func invalidateLayout(with context: UICollectionViewLayoutInvalidationContext) { //以context的资讯，做些update} 系统提供可用的失效标记，无任何标记将会重新进入『配置流程』 这些标记的功用，是在第一个function根据bounds作上标记，在第二个funciton中可以根据以下对应的变数取得当初的标记，做对应的『局部属性预处理』。 有标记可做 局部属性预处理 ，并会被重新询问 Attribute 重新询问 Attribute例如：若滑超过 1/2 Y，使 row 17 失效。 12345678override func invalidationContext(forBoundsChange newBounds: CGRect) -&gt; UICollectionViewLayoutInvalidationContext { let invalidationContext = super.invalidationContext(forBoundsChange: newBounds) if newBounds.maxY &gt; contentSize.height { invalidationContext.invalidateItems(at: [IndexPath(row: 17, section: 0)]) } return invalidationContext} 覆写的此function就会被调用并询问 row17 的attribute 123override func layoutAttributesForItem(at indexPath: IndexPath) -&gt; UICollectionViewLayoutAttributes? { return row17's attribute} 局部属性预处理局部属性预处理 其实就是为了上一步 『重新询问 Attribute』这块做预先计算， 例如：若滑超过 1/2 Y，使 某Decoration失效。 1234567891011override func invalidationContext(forBoundsChange newBounds: CGRect) -&gt; UICollectionViewLayoutInvalidationContext { let invalidationContext = super.invalidationContext(forBoundsChange: newBounds) if newBounds.maxY &gt; contentSize.height { invalidationContext.invalidateDecorationElements( ofKind: &quot;Footer&quot;, at: [IndexPath(item: 1, section: 0)] ) } return invalidationContext} 并在 invalidateLayout(with:) 从context里查询是否对应的Decoration包含在失效名单内，并提前计算好心的Attribute存在持有变量 123456override func invalidateLayout(with context: UICollectionViewLayoutInvalidationContext) { let invalidationContext = context if let dic = context.invalidatedDecorationIndexPaths, let idx = dic[&quot;Footer&quot;] { prepareFooterViewAttributes() }} 在询问的时候，将预先计算好的Attribute 回传 1234567override public func layoutAttributesForDecorationView( ofKind elementKind: String, at indexPath: IndexPath) -&gt; UICollectionViewLayoutAttributes? { return self.footerLayoutAttributes} 特殊标记 (get-only) 这两个特殊标记是会在触发 collectionView.reloadData()时会被系统自动启用，不能自己设置，并且仍会重新进入『配置流程』。 基于系统『自定义』的 InvalidationContext 失效layout第一步当然是写一个继承UICollectionViewLayoutInvalidationContext的类，并且在UICollectionViewLayout类里覆写以下 123override class var invalidationContextClass: AnyClass { return InvalidationContext子类名.self} 自定义 InvalidationContext 的好处不外乎就是能自己增加字段，能更清晰也更有逻辑的衔接前后两个函数 例如：沿用前面的例子，但InvalidationContext为自定义，增加一个Bool，判断哪部分需要失效或是需要被标记 12345678910111213141516171819202122232425class LayoutInvalidationContext: UICollectionViewLayoutInvalidationContext { var invalidateFooter = false}override func invalidationContext(forBoundsChange newBounds: CGRect) -&gt; UICollectionViewLayoutInvalidationContext { let invalidationContext = super.invalidationContext(forBoundsChange: newBounds) as! LayoutInvalidationContext guard let collectionView = collectionView else { return invalidationContext } let originChanged = !collectionView.bounds.origin.equalTo(newBounds.origin) if originChanged &amp;&amp; newBounds.maxY &gt; contentSize.height { invalidationContext.invalidateFooter = true } return invalidationContext}override func invalidateLayout(with context: UICollectionViewLayoutInvalidationContext) { let invalidationContext = context as! LayoutInvalidationContext if invalidationContext.invalidateFooter { prepareFooterViewAttributes() invalidationContext.invalidateDecorationElements( ofKind: &quot;Footer&quot;, at: [IndexPath(item: 1, section: 0)] ) } super.invalidateLayout(with: invalidationContext)}","link":"/blog/2018/07/03/UICollectionViewLayoutInvalidationContext/"},{"title":"深入淺出 Xcode 命令列(加餐) - libxcselect.dylib","text":"Xcode命令列 = Xcode Command Lines Tool 經過深入淺出 Xcode 命令列(1) - 初探的介紹，我們知道一台mac上可能會有多’組’xcode command line tool. 且在xcode-select的幫助下，我們能指定某個特定版本的Command Line Tools，然後整台電腦在不需要設定env變量的前提下，就知道該調那個SDK了…. 聽起來很符合直覺，卻有點太玄了…😰 – 讓我們稍微深追一下這問題 礙於我的知識有限，所以這篇寫做加餐，咱們點到為止😅 things we know複習一下，當我們在終端敲命令(例如: xcodebuild)時，系統都會在 $PATH 這個環境變量裡給的路徑裡尋找你敲的指令的object file。 echo $PATH 所以輸入 git, 其實是執行了 /usr/bin/xcodebuild which git 以上都是我們熟知的原理。 things we don’t know我們現在已xcodebuild為例，來看看後面有關xcode command line tools的流程。 我對詳細的逆向函數還不是很熟悉，所以統整了一些參考文章，想要深入暸解的可以點擊文章底部鏈接。 看看/usr/bin/xcodebuild 下的指令是怎麼配合xcode-select , 找到 /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild？ 首先我們就對 /usr/bin/xcodebuild 動手列出 /usr/bin/xcodebuild 的 textsection 再打印 /usr/bin/xcodebuild 的 name list 結合這兩個信息，我們可以得出 調用了一個 _xcselect_invoke_xcrun 函數 這個函數對 /usr/bin/xcodebuild 來說是一個外部符號，來自另一個動態庫，交給動態鏈接去做了。 接著 打印 /usr/bin/xcodebuild依賴的庫 可以看到有 libxcselect.dylib, libSystem.B.dylib, 打印 libxcselect.dylib 的 name list 看看 _xcselect_invoke_xcrun這symbol 在不在這 bingo! 找到了 跟著 Swift-Swiftc 作者的追蹤，可以得到如下 1234567libxcselect.dylib-&gt;_xcselect_invoke_xcrun-&gt; libxcrun.dylib-&gt;xcrun_main 而最後的 xcrun_main -&gt; 指向的就是 指令 xcrun xcrun截至目前，我們能把上面的所有堆棧，抽象大概濃縮成一行函數，類似於 xcrun('xcodebuild') 而xcrun 就會引領我們到 /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild 至於xcrun的用法，我們下回分曉。 撥雲見日 參考文章： Swift-Swiftc mans-special-xcode-support os-x-and-xcode-doing-it-apple-way","link":"/blog/2019/12/20/xcCmdLine-1_2/"},{"title":"向Hero致敬與分析-(二)","text":"本篇继上篇：http://www.jianshu.com/p/fdab69f7440a本篇重点： Plugin heroModifierString 1.3.1)Present流程 - start() - Plugin, HeroPreprocessor , HeroAnimator1234567public func animateTransition(using context: UIViewControllerContextTransitioning) { /* 略.*/ start()} 我们来到最主要的程式段：start() 1234567891011func start() { plugins == nil { print(&quot;plugins == nil&quot;) //把enabledPlugins里的每个类别全部init后放进 plugins = Hero.enabledPlugins.map({ return $0.init() }) } /* 略.*/} 一开头就是我们没见过的plugins这个变数，所以我们先来浅谈plugins是什么。 Plugin是Hero提供可以让使用者、开发者自行在做自定义的处理动画或是其他变数处理。只要让类别实作HeroPlugin(继承HeroPreprocessor, HeroAnimator两个协定)这个类别，即可在过场的进行时，收到以下通知： 现在我们来看看HeroPreprocessor, HeroAnimatorHero有以下两个变数，可以把它们想成两条线程，一条专门做一系列的HeroPreprocessor, 而另一条则做一系列的HeroAnimator。上面提到的Plugin同时属于这两类。 123456789101112131415161718192021222324252627282930 var processors: [HeroPreprocessor]! var animators: [HeroAnimator]!func start() {/* 略 */processors = Hero.builtInProcessors //Hero内建程序animators = Hero.builtInAnimator //Hero内建动画 // 如果有插件的话就加进程序 for plugin in plugins { processors.append(plugin) animators.append(plugin) }/* 略 */// ask each preprocessor to process for processor in processors { processor.process(context:context, fromViews: context.fromViews, toViews: context.toViews) }/* 略 */ for animator in animators.reversed() { let currentFromViews = fromViews.filterInPlace{ [context] (view:UIView) -&gt; Bool in return !animator.canAnimate(context: context!, view: view, appearing: false) } let currentToViews = toViews.filterInPlace{ [context] (view:UIView) -&gt; Bool in return !animator.canAnimate(context: context!, view: view, appearing: true) } animatorViews.insert((currentFromViews, currentToViews), at: 0) }} 1.3.2)Present流程 - start() - 制作过场”舞台”复制一个起始view(from view)盖上去(animatingViewContainer)，之后所有动画都在上面进行，算是最好懂的一块。 123456789101112131415161718func start() {/* 略 */transitionContainer.isUserInteractionEnabled = false // a view to hold all the animation views //transitionContainer是在context拿到的 animatingViewContainer = UIView(frame: transitionContainer.bounds) transitionContainer.addSubview(animatingViewContainer) //加上一个空的等大容器 // create a snapshot view to hide all the flashing that might happen let completeSnapshot = fromView.snapshotView(afterScreenUpdates: true)! transitionContainer.addSubview(completeSnapshot) animatingViewContainer.addSubview(fromView) animatingViewContainer.insertSubview(toView, belowSubview: fromView) animatingViewContainer.backgroundColor = toView.backgroundColor/* 略 */context = HeroContext(container:animatingViewContainer, fromView: fromView, toView:toView)} 1.4)HeroContext这个类别算是Hero的特色也是最有技巧性的一部分。主要处理这两个 “HeroID”, “heroModifierString” 1.4.1) heroModifierString一句话概括它，就是“指令”，指示这个View要执行怎样的过场动画。使用者在StoryBoard或是swift里给定ModifierString后，即在变数的set{…}将字串转为可执行的function指令。 1234567891011121314151617181920212223public extension UIView{ /* 略 */@IBInspectable public var heroModifierString: String? { /* 略 */ let modifierString = newValue as NSString var modifiers = [HeroModifier]() //function结果 //modifiersRegex = &quot;(\\\\w+)(?:\\\\(([^\\\\)]*)\\\\))?&quot; for r in matches(for: modifiersRegex, text:modifierString) //A Loop { var parameters = [String]() if r.numberOfRanges &gt; 2, r.rangeAt(2).location &lt; modifierString.length { let parameterString = modifierString.substring(with: r.rangeAt(2)) as NSString //parameterRegex = &quot;(?:\\\\-?\\\\d+(\\\\.?\\\\d+)?)|\\\\w+&quot; for r in matches(for: parameterRegex, text: parameterString){ //B Loop parameters.append(parameterString.substring(with: r.range)) } } let name = modifierString.substring(with: r.rangeAt(1)) //取得Function if let modifier = HeroModifier.from(name: name, parameters: parameters){ modifiers.append(modifier) /*略*/ numberOfRanges：regx的组数，最外层()的数量。 rangeAt(0) = 有符合的结果, rangeAt(1) = 有一组以上，rangeAt(2) = 有两组以上…… A Loop: 找出 一个以上非空白 可能出现一对括号 中间夹着多个非右括号 = 一个Fuction的格式 , 若 numberOfRanges &gt; 2 则代表有(参数)。B Loop: 参数 可是一串非空白 或是 数子（可负数或小数) EX: heroModifierString = zPosition(2) arc parameterString = 2 , name = zPositionname = arc 读出个别指令后就是利用一个配对Function，可以看到最终每个字串有配对结果的话，可以得到一个个的**”闭包（Closure）”** 12345678910111213141516171819202122232425262728public class HeroModifier { internal let apply:(inout HeroTargetState) -&gt; Void public init(applyFunction:@escaping (inout HeroTargetState) -&gt; Void){ apply = applyFunction }/*略*/static func from(name:String, parameters:[String]) -&gt; HeroModifier?{switch name { case &quot;zPosition&quot;: if let zPosition = parameters.getCGFloat(0){ //拿参数 modifier = .zPosition(zPosition) }}/*略*/public static func zPosition(_ zPosition:CGFloat) -&gt; HeroModifier { return HeroModifier { targetState in targetState.zPosition = zPosition } }}/*略*/ public static func arc(intensity:CGFloat = 1) -&gt; HeroModifier { return HeroModifier { targetState in targetState.arc = intensity } } 走到这么深之后，我们现在在回extension UIView顶层看看另外一个扩充变数， 123public extension UIView{/*略*/public var heroModifiers: [HeroModifier]? 现在我们可以把它理解成一个可执行的闭包集合，因为每个HeroModifier都自带一个闭包 apply:(inout HeroTargetState) -&gt; Void 它记着一个View在过场时，所有要执行的过场动画，可利用modifier.apply(&amp;HeroTargetState)呼叫。","link":"/blog/2017/01/18/Hero_Part2/"},{"title":"深入淺出 Xcode 命令列(2)-xcrun 基礎","text":"Xcode命令列 = Xcode Command Lines Tool 前言回顧一下上一篇加餐, 1234567libxcselect.dylib-&gt;_xcselect_invoke_xcrun-&gt; libxcrun.dylib-&gt;xcrun_main 我們最後發現所有Xcode Command Line 都會先被導向 xcrun_main，也就是 xcrun。 於是xcrun就成了第一個探討對象 xcrunxcrun 本名 : command-line tool runner, 如果把第一篇說的xcode-select形容成多組Command Line tools中的引路人， xcrun就可以理解為某一組Command Line tools的敲門磚。 先來看xcrun的man, man xcrun 描述裡說的，跟 xcode-select基本上大同小異，例如： 12xcrun provides a means to locate or invoke developer tools from the command-line, without requiring users to modify Makefiles or otherwise take inconvenient measures to support multiple Xcode tool chains 不外乎就是說可以再多組Command Line Tools裡面找到定位到該執行的指令。 描述甚至在還提到了xcode-select，就像我上面說的要走到真正的executable， 是 xcode-select(引路人)、xcrun(敲門磚) 兩位相輔相成才走得到。 由xcode-selct -s 決定的xcode command Line路徑，xcrun再依照這路徑 定位／執行命令。 把第一篇的這張圖擴充一下： Usage已 Command line tools 裡的 clang 為例: 作為參考, xcode-select 的 pathxcode-select -p/Applications/Xcode.app/Contents/Developer xcrun clang 此指令等價於執行以下指令 ⬇️ clang /usr/bin/clang == (which clang) 詳情參考上一篇加餐 /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang xcrun --find clang /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang xcrun --find git /Applications/Xcode.app/Contents/Developer/usr/bin/git Futher More一般介紹xcrun的文章到這邊大概就會止住了，大概的總結：xcrun 後面接指令就可以怎麼樣怎麼樣，然後接著介紹後面的指令。 但看到 xcrun --find clang &amp; xcrun --find git 的輸出， 一個是 /Toolchains/XcodeDefault.xctoolchain/usr/bin/clang 一個是 /usr/bin/git 給我一個感覺就是 xcrun 除了走xcode-select指引的大路，自己裡面還有很多小路！ 所以我想就這個問題在深挖 xcrun。而的確一組command line Tools裡還能在拆分成三類的指令 這三大類分別為 - Developer SDKs(Platforms) ToolChain 關於這三類之間的依賴，以及xcrun剩餘的用法，請允許我拖更到下一篇文章😅 reference: b-man/xcode-tools","link":"/blog/2019/12/23/xcCmdLine-2/"}],"tags":[{"name":"Model","slug":"Model","link":"/blog/tags/Model/"},{"name":"Codable","slug":"Codable","link":"/blog/tags/Codable/"},{"name":"iOS","slug":"iOS","link":"/blog/tags/iOS/"},{"name":"Xcode","slug":"Xcode","link":"/blog/tags/Xcode/"},{"name":"Compiler","slug":"Compiler","link":"/blog/tags/Compiler/"},{"name":"Clang","slug":"Clang","link":"/blog/tags/Clang/"},{"name":"LLVM","slug":"LLVM","link":"/blog/tags/LLVM/"},{"name":"MapKit","slug":"MapKit","link":"/blog/tags/MapKit/"},{"name":"地圖","slug":"地圖","link":"/blog/tags/%E5%9C%B0%E5%9C%96/"},{"name":"CGContext","slug":"CGContext","link":"/blog/tags/CGContext/"},{"name":"UI控件","slug":"UI控件","link":"/blog/tags/UI%E6%8E%A7%E4%BB%B6/"},{"name":"UIKit","slug":"UIKit","link":"/blog/tags/UIKit/"},{"name":"SpriteKit","slug":"SpriteKit","link":"/blog/tags/SpriteKit/"},{"name":"過場動畫","slug":"過場動畫","link":"/blog/tags/%E9%81%8E%E5%A0%B4%E5%8B%95%E7%95%AB/"},{"name":"WebView","slug":"WebView","link":"/blog/tags/WebView/"},{"name":"網路","slug":"網路","link":"/blog/tags/%E7%B6%B2%E8%B7%AF/"},{"name":"Command Line Tools","slug":"Command-Line-Tools","link":"/blog/tags/Command-Line-Tools/"},{"name":"xcode-select","slug":"xcode-select","link":"/blog/tags/xcode-select/"},{"name":"Framework","slug":"Framework","link":"/blog/tags/Framework/"},{"name":"庫","slug":"庫","link":"/blog/tags/%E5%BA%AB/"},{"name":"ColletionView","slug":"ColletionView","link":"/blog/tags/ColletionView/"},{"name":"xcrun","slug":"xcrun","link":"/blog/tags/xcrun/"}],"categories":[{"name":"iOS","slug":"iOS","link":"/blog/categories/iOS/"},{"name":"Xcode","slug":"Xcode","link":"/blog/categories/Xcode/"},{"name":"開源代碼","slug":"iOS/開源代碼","link":"/blog/categories/iOS/%E9%96%8B%E6%BA%90%E4%BB%A3%E7%A2%BC/"},{"name":"開源研究","slug":"iOS/開源研究","link":"/blog/categories/iOS/%E9%96%8B%E6%BA%90%E7%A0%94%E7%A9%B6/"},{"name":"Compiler","slug":"Xcode/Compiler","link":"/blog/categories/Xcode/Compiler/"},{"name":"Http","slug":"iOS/Http","link":"/blog/categories/iOS/Http/"},{"name":"命令列","slug":"Xcode/命令列","link":"/blog/categories/Xcode/%E5%91%BD%E4%BB%A4%E5%88%97/"},{"name":"Framework","slug":"Xcode/Framework","link":"/blog/categories/Xcode/Framework/"},{"name":"性能優化","slug":"iOS/性能優化","link":"/blog/categories/iOS/%E6%80%A7%E8%83%BD%E5%84%AA%E5%8C%96/"},{"name":"LLVM","slug":"Xcode/Compiler/LLVM","link":"/blog/categories/Xcode/Compiler/LLVM/"}]}